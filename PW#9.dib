#!meta

{"kernelInfo":{"defaultKernelName":"csharp","items":[{"aliases":[],"languageName":"csharp","name":"csharp"}]}}

#!markdown

# Практическая работа №9. Реализация длительных операций.

**Цель:** Предоставить возможность выполннеия команд, для полного завершения которых требуется более одного вызова Execute.

**Результаты:** После выполнения работы Вы сможете:
1. Выполнять длительные опреации в отдельном потоке без монопольного использования потока в течение длительного времени.
3. Прерывать выполнение таких команд. 


## Задание.
Если для полного выполнения командв потребуется более одного вызова Execute, необходимо такую команду добавить в планировщик.

Для иллюстрации выполнненой работы определить команду

#!csharp

public interface ICommand
{
    void Execute();
    bool IsCompleted();
}


public class TestCommand(int id) : ICommand
{
    int counter = 0;

    public void Execute()
    {
        Console.WriteLine($"Поток {id} вызов {++counter}");
    }
    
    public bool IsCompleted()
    {
        return counter >= 3;
    }
}

#!csharp

public interface IScheduler
{
    bool HasCommand();
    ICommand Select();
    void Add(ICommand cmd);
}

#!markdown

Необходимо проиллюстрировать выполнение 5 экземпляров TestCommand 3 раза, затем остановить поток с помощью HardStop.

#!csharp

using System;
using System.Collections.Concurrent;
using System.Threading;

#!csharp

public class RoundRobinScheduler : IScheduler
{
    private ConcurrentQueue<ICommand> commandQueue = new ConcurrentQueue<ICommand>();
    private readonly object lockObject = new object();

    public bool HasCommand()
    {
        return commandQueue.Count() > 0;
    }

    public ICommand Select()
    {
        lock (lockObject)
        {
            if (commandQueue.TryDequeue(out ICommand cmd))
            {
                return cmd;
            }
            return null;
        }
    }

    public void Add(ICommand cmd)
    {
        commandQueue.Enqueue(cmd);
    }
}

#!csharp

public class ServerThread
{
    private ConcurrentQueue<ICommand> commands = new ConcurrentQueue<ICommand>();
    private bool hardStop = false;
    private bool softStop = false;
    public bool isRunning = true;
    private IScheduler scheduler = new RoundRobinScheduler();
    public int id { get; set; }
    private bool useScheduler = true;

    public void Start()
    {
        Thread thread = new Thread(Run);
        thread.Start();
        id = thread.ManagedThreadId;
    }

    public void AddToQueue(ICommand command)
    {    
        if (command is HardStopCommand)
        {
            Console.WriteLine($"Queue coinains {commands.Count()} elements, executing hart stop");
            commands.Clear();
            commands.Enqueue(command);
        }        
        else {commands.Enqueue(command);}
    }

    public void HardStop()
    {
        hardStop = true;
    }

    public void SoftStop()
    {
        softStop = true;
    }

    private void Run()
    {
        while(!hardStop)
        {
            if (scheduler.HasCommand() && (useScheduler || !(commands.Count() > 0)))
            {
                var command = scheduler.Select();
                if (command != null)
                {
                    command.Execute();
                    if (!command.IsCompleted())
                    {
                        scheduler.Add(command);
                    }
                }
                useScheduler = false;
            }
            else if (commands.TryDequeue(out ICommand command))
            {
                command.Execute();
                if (!command.IsCompleted())
                {
                    scheduler.Add(command);
                }
                useScheduler = true;
            }
            else
            {
                if(softStop){break;}
                Thread.Sleep(100);
                useScheduler = true;
            }
        }
        isRunning = false;
    }
}
public class HardStopCommand : ICommand
{
    private ServerThread thread;

    public HardStopCommand(ServerThread thread)
    {
        this.thread = thread;
    }

    public void Execute()
    {
        if(Thread.CurrentThread.ManagedThreadId == thread.id)
        {
            thread.HardStop();
        }
        else
        {
            throw new ("HardStop can only be executed in the thread it is stopping");
        }
    }
    public bool IsCompleted(){return true;} 
}

public class SoftStopCommand : ICommand
{
    private ServerThread thread;

    public SoftStopCommand(ServerThread thread)
    {
        this.thread = thread;
    }

    public void Execute()
    {
        if(Thread.CurrentThread.ManagedThreadId == thread.id) 
        {
            thread.SoftStop();
        }
        else
        {
            throw new ("SoftStop can only be executed in the thread it is stopping");
        }
    }
    public bool IsCompleted(){return true;} 
}

#!csharp

ServerThread sr_thread = new ServerThread();
TestCommand[] test_commands = new TestCommand[]{new TestCommand(1), new TestCommand(2), new TestCommand(3), new TestCommand(4), new TestCommand(5)};
sr_thread.Start();
for(int i = 0; i < 5; i ++)
{
    sr_thread.AddToQueue(test_commands[i]);
}
while(sr_thread.isRunning)
{
    bool check = true;
    foreach(TestCommand cmd in test_commands)
    {
        check = check && cmd.IsCompleted();
    }
    if(check){sr_thread.AddToQueue(new HardStopCommand(sr_thread));break;}
    Thread.Sleep(100);
}
Console.WriteLine("All threads finished work");
